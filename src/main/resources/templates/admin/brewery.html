<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      th:replace="~{layouts/app :: layout('Brewery Control Center', 'brewery', 'Quick overview and navigation for brewery operations.', ~{::section[@id='page-content']})}">
<section id="page-content">
  <section th:if="${componentLibraryEnabled}" class="page-section">
    <mt-enterprise-console
        id="brewConsole"
        th:attr="data-overrides=${consoleDataJson},
                  data-selected-domain=${consoleSelectedDomain},
                  data-brewery-id=${brewery != null ? brewery.id : ''},
                  data-brewery-name=${brewery != null ? brewery.name : 'Brewery'},
                  data-csrf-token=${_csrf != null ? _csrf.token : ''},
                  data-csrf-header=${_csrf != null ? _csrf.headerName : ''}"></mt-enterprise-console>
    <dialog id="createUserDialog" class="modal">
      <form id="createUserForm" method="dialog" class="stacked-form">
        <h2>Create user</h2>
        <p class="muted">Provide credentials and scope for the new account.</p>
        <div class="form-group">
          <label for="createUserUsername">Username</label>
          <input id="createUserUsername" name="username" type="text" required placeholder="team member" />
        </div>
        <div class="form-group">
          <label for="createUserPassword">Password</label>
          <input id="createUserPassword" name="password" type="password" required placeholder="******" />
        </div>
        <div class="form-group">
          <label for="createUserRole">Role</label>
          <select id="createUserRole" name="role" required>
            <option value="BREWERY_ADMIN">Brewery Admin</option>
            <option value="TAPROOM_ADMIN">Taproom Admin</option>
            <option value="TAPROOM_USER" selected>Taproom User</option>
            <option value="BAR_ADMIN">Bar Admin</option>
            <option value="SITE_ADMIN">Site Admin</option>
          </select>
        </div>
        <div class="form-group">
          <label for="createUserTaproomId">Taproom ID <span class="muted">(optional)</span></label>
          <input id="createUserTaproomId" name="taproomId" type="number" min="1" placeholder="Taproom assignment" />
        </div>
        <div class="form-group">
          <label for="createUserBarId">Bar ID <span class="muted">(optional)</span></label>
          <input id="createUserBarId" name="barId" type="number" min="1" placeholder="Bar assignment" />
        </div>
        <p id="createUserError" class="form-error" role="alert" hidden></p>
        <div class="form-actions">
          <button type="button" class="btn secondary" data-action="cancel">Cancel</button>
          <button type="submit" class="btn primary">Create user</button>
        </div>
      </form>
    </dialog>
    <script th:inline="javascript">
      /*<![CDATA[*/
      window.lastCsrfDebug = { version: '20250922c', lastUpdated: Date.now(), event: 'init' };
      window.lastCsrfRequest = null;
      window.lastCsrfResponse = null;

      const consoleEl = document.getElementById('brewConsole');
      const venuesCache = { list: null, loading: false };
      const queueSize = 6;
      const activitySize = 5;
      let csrfHeaderName = 'X-XSRF-TOKEN';

      (function () {
        if (!consoleEl) {
          return;
        }
        const overridesRaw = consoleEl.dataset.overrides || '{}';
        const selectedDomainRaw = consoleEl.dataset.selectedDomain || '';
        const breweryIdValue = consoleEl.dataset.breweryId || '';
        const breweryName = consoleEl.dataset.breweryName || 'Brewery';
        csrfHeaderName = consoleEl.dataset.csrfHeader || 'X-XSRF-TOKEN';
        const breweryId = breweryIdValue ? Number(breweryIdValue) : null;
        const createUserDialog = document.getElementById('createUserDialog');
        const createUserForm = document.getElementById('createUserForm');
        const createUserError = document.getElementById('createUserError');
        const createUserCancelButton =
          createUserDialog ? createUserDialog.querySelector('[data-action="cancel"]') : null;
        let createUserSubmitting = false;

        if (createUserForm) {
          createUserForm.addEventListener('submit', handleCreateUserSubmit);
          const roleSelect = createUserForm.querySelector('select[name="role"]');
          if (roleSelect) {
            roleSelect.value = 'TAPROOM_USER';
          }
        }
        if (createUserCancelButton) {
          createUserCancelButton.addEventListener('click', () => {
            if (!createUserSubmitting) {
              closeCreateUserDialog();
            }
          });
        }

        customElements
          .whenDefined('mt-enterprise-console')
          .then(() => {
            try {
              const parsed = JSON.parse(overridesRaw);
              const merged = Object.assign({}, consoleEl.domains || {}, parsed);
              consoleEl.domains = merged;
              if (selectedDomainRaw) {
                consoleEl.selectedDomain = selectedDomainRaw;
              }
            } catch (err) {
              console.warn('Unable to hydrate brewery console', err);
            }

            if (breweryId) {
              hydrateIdentityDomain({ selectDomain: true });
            }
          })
          .catch((err) => console.error('Enterprise console not available', err));

        consoleEl.addEventListener('enterprise-command', async (event) => {
          const detail = event.detail || {};
          const command = detail.command || {};

          if (!command.type) {
            window.alert('Action not yet supported in this prototype.');
            return;
          }

          try {
            switch (command.type) {
              case 'create-user': {
                handleCreateUserAction();
                return;
              }
              case 'assign': {
                const kegId = command.kegId;
                if (!kegId) {
                  window.alert('No eligible kegs for that action right now.');
                  return;
                }
                const venueId = await chooseVenue();
                if (!venueId) {
                  return;
                }
                await postJson('/api/v1/keg-inventory/assign', { kegId, venueId });
                window.alert('Keg assigned successfully.');
                await refreshKegInventory();
                break;
              }
              case 'return': {
                const kegId = command.kegId;
                if (!kegId) {
                  window.alert('No eligible kegs for that action right now.');
                  return;
                }
                await postJson('/api/v1/keg-inventory/return', { kegId });
                window.alert('Keg return recorded.');
                await refreshKegInventory();
                break;
              }
              case 'clean': {
                const kegId = command.kegId;
                if (!kegId) {
                  window.alert('No eligible kegs for that action right now.');
                  return;
                }
                await postJson(`/api/v1/kegs/${kegId}/clean`, {});
                window.alert('Keg marked as clean.');
                await refreshKegInventory();
                break;
              }
              default:
                window.alert('Action not yet supported in this prototype.');
                return;
            }
          } catch (error) {
            console.error('Failed to execute command', error);
            window.alert('Unable to complete that action.');
          }
        });

        function handleCreateUserAction() {
          if (createUserDialog && typeof createUserDialog.showModal === 'function') {
            openCreateUserDialog();
            return;
          }
          fallbackCreateUserPrompt();
        }

        function openCreateUserDialog() {
          if (!createUserDialog) {
            fallbackCreateUserPrompt();
            return;
          }
          createUserSubmitting = false;
          if (createUserForm) {
            createUserForm.reset();
            setCreateUserSubmitting(false);
            const roleSelect = createUserForm.querySelector('select[name="role"]');
            if (roleSelect) {
              roleSelect.value = 'TAPROOM_USER';
            }
            const usernameInput = createUserForm.querySelector('#createUserUsername');
            if (usernameInput) {
              usernameInput.focus();
            }
          }
          clearCreateUserError();
          if (typeof createUserDialog.showModal === 'function') {
            createUserDialog.showModal();
          } else {
            createUserDialog.setAttribute('open', 'true');
          }
        }

        function closeCreateUserDialog() {
          if (!createUserDialog) {
            return;
          }
          clearCreateUserError();
          if (typeof createUserDialog.close === 'function') {
            createUserDialog.close();
          } else {
            createUserDialog.removeAttribute('open');
          }
        }

        function clearCreateUserError() {
          if (createUserError) {
            createUserError.textContent = '';
            createUserError.hidden = true;
          }
        }

        function setCreateUserError(message) {
          if (createUserError) {
            createUserError.textContent = message || 'Unable to create user.';
            createUserError.hidden = false;
            return;
          }
          if (message) {
            window.alert(message);
          }
        }

        function setCreateUserSubmitting(isSubmitting) {
          if (!createUserForm) {
            return;
          }
          const submitButton = createUserForm.querySelector('button[type="submit"]');
          if (submitButton) {
            submitButton.disabled = isSubmitting;
            submitButton.textContent = isSubmitting ? 'Creating...' : 'Create user';
          }
          if (createUserCancelButton) {
            createUserCancelButton.disabled = isSubmitting;
          }
        }

        async function handleCreateUserSubmit(event) {
          event.preventDefault();
          if (createUserSubmitting || !createUserForm) {
            return;
          }

          clearCreateUserError();

          const data = new FormData(createUserForm);
          const username = String(data.get('username') || '').trim();
          const password = String(data.get('password') || '');
          const roleValue = String(data.get('role') || '').trim().toUpperCase();
          const taproomId = parseOptionalId(data.get('taproomId'));
          const barId = parseOptionalId(data.get('barId'));

          if (!username) {
            setCreateUserError('Username is required.');
            return;
          }
          if (!password) {
            setCreateUserError('Password is required.');
            return;
          }
          if (!roleValue) {
            setCreateUserError('Role is required.');
            return;
          }
          if (Number.isNaN(taproomId)) {
            setCreateUserError('Taproom ID must be a positive number.');
            return;
          }
          if (Number.isNaN(barId)) {
            setCreateUserError('Bar ID must be a positive number.');
            return;
          }
          if (!breweryId && roleValue !== 'SITE_ADMIN') {
            setCreateUserError('Brewery context is required to create this user.');
            return;
          }

          const payload = {
            username,
            password,
            role: roleValue
          };

          if (breweryId) {
            payload.breweryId = breweryId;
          }
          if (taproomId) {
            payload.taproomId = taproomId;
          }
          if (barId) {
            payload.barId = barId;
          }

          createUserSubmitting = true;
          setCreateUserSubmitting(true);

          try {
            await postJson('/api/v1/users', payload);
            window.alert(`User ${username} created successfully.`);
            closeCreateUserDialog();
            createUserForm.reset();
            await hydrateIdentityDomain({ selectDomain: true });
          } catch (error) {
            console.error('Failed to create user', error);
            const message = error?.message || 'Unable to create user.';
            setCreateUserError(message);
          } finally {
            createUserSubmitting = false;
            setCreateUserSubmitting(false);
          }
        }

        function parseOptionalId(rawValue) {
          if (rawValue == null) {
            return null;
          }
          const value = String(rawValue).trim();
          if (!value) {
            return null;
          }
          const parsed = Number(value);
          if (!Number.isFinite(parsed) || parsed <= 0) {
            return Number.NaN;
          }
          return parsed;
        }

        async function fallbackCreateUserPrompt() {
          const username = window.prompt('Enter a username for the new user');
          if (!username) {
            return;
          }
          const password = window.prompt(`Enter a temporary password for ${username}`);
          if (!password) {
            return;
          }
          const role = window
            .prompt(
              'Enter a role (SITE_ADMIN, BREWERY_ADMIN, TAPROOM_ADMIN, TAPROOM_USER, BAR_ADMIN)',
              'TAPROOM_USER'
            )
            ?.toUpperCase()
            .trim();
          if (!role) {
            return;
          }
          if (!breweryId && role !== 'SITE_ADMIN') {
            window.alert('Brewery context is required to create this user.');
            return;
          }

          const payload = {
            username: username.trim(),
            password,
            role
          };
          if (breweryId) {
            payload.breweryId = breweryId;
          }

          try {
            await postJson('/api/v1/users', payload);
            window.alert(`User ${payload.username} created successfully.`);
            await hydrateIdentityDomain({ selectDomain: true });
          } catch (error) {
            console.error('Unable to create user', error);
            window.alert('Unable to create user.');
          }
        }

        async function hydrateIdentityDomain({ selectDomain = false } = {}) {
          if (!breweryId || !consoleEl) {
            return;
          }
          try {
            const url = new URL('/api/v1/users', window.location.origin);
            url.searchParams.set('breweryId', String(breweryId));
            url.searchParams.set('size', '25');
            const response = await fetch(url.toString(), {
              headers: { Accept: 'application/json' },
              credentials: 'include'
            });
            if (!response.ok) {
              throw new Error(`Failed to load users (${response.status})`);
            }
            const payload = await response.json();
            const domain = buildIdentityDomainFromApi(payload, breweryName);
            const current = consoleEl.domains ? { ...consoleEl.domains } : {};
            consoleEl.domains = Object.assign(current, { iam: domain });
            if (selectDomain) {
              consoleEl.selectedDomain = 'iam';
            }
            syncCsrfTokenFromCookie();
          } catch (error) {
            console.warn('Unable to load brewery users', error);
            if (consoleEl) {
              consoleEl.domains = Object.assign({}, consoleEl.domains || {});
            }
          }
        }

        function buildIdentityDomainFromApi(payload, breweryName) {
          const content = Array.isArray(payload?.content) ? payload.content : [];
          const total = typeof payload?.totalElements === 'number' ? payload.totalElements : content.length;

          const roleLabel = (role) => (role ? role.replace(/_/g, ' ').toUpperCase() : 'UNKNOWN');
          const admins = content.filter((user) => user.role === 'BREWERY_ADMIN').length;
          const taproomStaff = content.filter((user) => user.role && user.role.startsWith('TAPROOM')).length;
          const barAdmins = content.filter((user) => user.role === 'BAR_ADMIN').length;

          const queue = content.slice(0, 6).map((user) => ({
            title: user.username,
            status: roleLabel(user.role),
            meta: user.taproomId
              ? `Taproom ID ${user.taproomId}`
              : user.barId
                  ? `Bar ID ${user.barId}`
                  : breweryName,
            severity: user.role === 'BREWERY_ADMIN' ? 'warning' : 'default'
          }));
          if (!queue.length) {
            queue.push({
              title: 'No users found',
              status: 'Action',
              meta: 'Create accounts to unlock team workflows',
              severity: 'alert'
            });
          }

          const activity = content.slice(0, 4).map((user) => ({
            time: '--',
            summary: `${user.username} holds ${roleLabel(user.role)} access`,
            badge: 'User'
          }));
          if (!activity.length) {
            activity.push({ time: '--', summary: 'No identity updates yet', badge: 'Info' });
          }

          return {
            key: 'iam',
            title: 'Identity & Access',
            breadcrumb: ['Mythic Tales', breweryName, 'Identity'],
            contexts: [
              `Brewery: ${breweryName}`,
              `Admins: ${admins}`,
              `Taproom staff: ${taproomStaff}`
            ],
            whatChanged: [
              `${total} total accounts scoped to the brewery`,
              `${barAdmins} bar admin${barAdmins === 1 ? '' : 's'} available`
            ],
            hero: [
              { label: 'Team Members', value: String(total), detail: 'Accounts in scope' },
              { label: 'Brewery Admins', value: String(admins), detail: 'Manage operations' },
              { label: 'Taproom Staff', value: String(taproomStaff), detail: 'Front of house' }
            ],
            queue,
            activity,
            quickActions: [
              { label: 'Create User', command: { type: 'create-user' } },
              { label: 'Manage Team', href: '/admin/brewery?tab=users' },
              { label: 'Invite User', href: '/admin/brewery?tab=users' },
              { label: 'Assign Taproom', href: '/admin/brewery?tab=users' }
            ],
            quickMeta: 'Identity shortcuts'
          };
        }
      })();

      async function refreshKegInventory() {
        const breweryIdValue = consoleEl.dataset.breweryId || '';
        if (!breweryIdValue) {
          return;
        }
        try {
          const url = new URL('/api/v1/keg-inventory/summary', window.location.origin);
          url.searchParams.set('breweryId', breweryIdValue);
          url.searchParams.set('queueSize', String(queueSize));
          url.searchParams.set('activitySize', String(activitySize));
          const response = await fetch(url.toString(), {
            headers: { 'Accept': 'application/json' },
            credentials: 'include'
          });
          if (!response.ok) {
            throw new Error(`Summary fetch failed (${response.status})`);
          }
          const summary = await response.json();
          const domains = consoleEl.domains ? { ...consoleEl.domains } : {};
          domains.keginventory = summary;
          consoleEl.domains = domains;
          consoleEl.selectedDomain = 'keginventory';
          syncCsrfTokenFromCookie();
        } catch (error) {
          console.error('Unable to refresh keg inventory summary', error);
        }
      }

      async function chooseVenue() {
        const breweryIdValue = consoleEl.dataset.breweryId || '';
        if (!breweryIdValue) {
          window.alert('No brewery context available.');
          return null;
        }
        const venues = await loadVenues(breweryIdValue);
        if (!venues.length) {
          window.alert('No venues available for assignment.');
          return null;
        }
        const options = venues
          .map((venue, index) => `${index + 1}) ${venue.name} [${venue.id}]`)
          .join('\n');
        const choice = window.prompt(
          'Select a venue for the keg assignment:\n' + options,
          '1'
        );
        if (!choice) {
          return null;
        }
        const idx = Number.parseInt(choice, 10) - 1;
        if (Number.isNaN(idx) || idx < 0 || idx >= venues.length) {
          window.alert('Invalid selection.');
          return null;
        }
        return venues[idx].id;
      }

      async function loadVenues(breweryId) {
        if (venuesCache.list) {
          return venuesCache.list;
        }
        if (venuesCache.loading) {
          return [];
        }
        venuesCache.loading = true;
        try {
          const url = `/api/v1/venues?breweryId=${breweryId}&size=200`;
          const response = await fetch(url, {
            headers: { 'Accept': 'application/json' },
            credentials: 'include'
          });
          if (!response.ok) {
            throw new Error(`Venue load failed (${response.status})`);
          }
          const payload = await response.json();
          venuesCache.list = Array.isArray(payload.content) ? payload.content : [];
          syncCsrfTokenFromCookie();
          return venuesCache.list;
        } catch (error) {
          console.error('Unable to load venues', error);
          return [];
        } finally {
          venuesCache.loading = false;
        }
      }

      async function postJson(url, body) {
        const headers = new Headers({
          'Content-Type': 'application/json',
          Accept: 'application/json'
        });
        const options = {
          method: 'POST',
          headers,
          credentials: 'include'
        };
        const csrfToken = resolveCsrfToken();
        if (csrfToken) {
          headers.set(csrfHeaderName, csrfToken);
          if (csrfHeaderName !== 'X-XSRF-TOKEN') {
            headers.set('X-XSRF-TOKEN', csrfToken);
          }
        }
        const requestDebug = {
          version: '20250922c',
          lastUpdated: Date.now(),
          event: 'request',
          url,
          headerName: csrfHeaderName,
          datasetToken: consoleEl && consoleEl.dataset ? consoleEl.dataset.csrfToken : null,
          cookieToken: csrfToken,
          headers: Object.fromEntries(headers.entries())
        };
        window.lastCsrfDebug = requestDebug;
        window.lastCsrfRequest = requestDebug;
        if (csrfToken) {
          console.debug('IAM csrf debug: request headers', requestDebug.headers);
        }
        if (body && Object.keys(body).length > 0) {
          options.body = JSON.stringify(body);
        }
        const response = await fetch(url, options);
        if (!response.ok) {
          const headers = Object.fromEntries(response.headers.entries());
          let responseBody;
          try {
            responseBody = await response.clone().json();
          } catch (_) {
            responseBody = await response.text();
          }
          const responseDebug = {
            version: '20250922c',
            lastUpdated: Date.now(),
            event: 'response-error',
            status: response.status,
            statusText: response.statusText,
            headers,
            datasetToken: consoleEl && consoleEl.dataset ? consoleEl.dataset.csrfToken : null,
            cookieToken: readCsrfToken(),
            body: responseBody
          };
          window.lastCsrfDebug = responseDebug;
          window.lastCsrfResponse = responseDebug;
          console.warn('IAM csrf debug: non-OK response', responseDebug);
          throw new Error(`Request failed (${response.status})`);
        }
        const result = await response
          .text()
          .then((text) => (text ? JSON.parse(text) : {}))
          .catch(() => ({}));
        const latestToken = readCsrfToken();
        if (latestToken && consoleEl && consoleEl.dataset) {
          consoleEl.dataset.csrfToken = latestToken;
        }
        const okDebug = {
          version: '20250922c',
          lastUpdated: Date.now(),
          event: 'response-ok',
          status: response.status,
          datasetToken: consoleEl && consoleEl.dataset ? consoleEl.dataset.csrfToken : null,
          cookieToken: latestToken
        };
        window.lastCsrfDebug = okDebug;
        window.lastCsrfResponse = okDebug;
        return result;
      }

      function resolveCsrfToken() {
        const fromCookie = readCsrfToken();
        if (fromCookie) {
          if (consoleEl && consoleEl.dataset) {
            consoleEl.dataset.csrfToken = fromCookie;
          }
          return fromCookie;
        }
        if (consoleEl && consoleEl.dataset && consoleEl.dataset.csrfToken) {
          return consoleEl.dataset.csrfToken;
        }
        return null;
      }

      function syncCsrfTokenFromCookie() {
        const latestToken = readCsrfToken();
        if (latestToken && consoleEl && consoleEl.dataset) {
          consoleEl.dataset.csrfToken = latestToken;
        }
      }

      function readCsrfToken() {
        if (!document.cookie) {
          return null;
        }
        const parts = document.cookie.split(';');
        for (const part of parts) {
          const trimmed = part.trim();
          if (trimmed.startsWith('XSRF-TOKEN=')) {
            return decodeURIComponent(trimmed.substring('XSRF-TOKEN='.length));
          }
        }
        return null;
      }
      /*]]>*/
    </script>
  </section>

  <th:block th:unless="${componentLibraryEnabled}">
  <section class="page-section">
    <div class="card-grid">
      <article class="metric-card">
        <header>
          <h3>Taprooms</h3>
          <span class="metric-pill success" th:text="${taproomCount} + ' active'">0 active</span>
        </header>
        <div class="metric-value" th:text="${taproomCount}">0</div>
        <footer class="muted">Taprooms linked to this brewery.</footer>
      <a class="card-link" th:href="@{/admin/brewery(tab='taprooms')}">View taprooms →</a>
      </article>
      <article class="metric-card">
        <header>
          <h3>Active tap handles</h3>
          <span class="metric-pill warning" th:text="${activeTapHandles} + ' pouring'">0 pouring</span>
        </header>
        <div class="metric-value" th:text="${activeTapHandles}">0</div>
        <footer class="muted">Live draft lines reporting a keg.</footer>
      <a class="card-link" th:href="@{/admin/brewery(tab='taprooms')}">Manage taprooms →</a>
      </article>
      <article class="metric-card">
        <header>
          <h3>Available kegs</h3>
          <span class="metric-pill info" th:text="${availableKegCount} + ' in house'">0 in house</span>
        </header>
        <div class="metric-value" th:text="${availableKegCount}">0</div>
        <footer class="muted">Unassigned, brewery-controlled inventory.</footer>
      <a class="card-link" th:href="@{/admin/brewery(tab='kegs')}">View kegs →</a>
      </article>
      <article class="metric-card">
        <header>
          <h3>Distributed / Returned</h3>
          <span class="metric-pill critical" th:text="${distributedKegCount} + ' out'">0 out</span>
        </header>
        <div class="metric-value" th:text="${returnedKegCount}">0</div>
        <footer class="muted">Returned kegs ready for cleaning.</footer>
      <a class="card-link" th:href="@{/admin/brewery(tab='assigned')}">Track distribution →</a>
      </article>
      <article class="metric-card">
        <header>
          <h3>Team members</h3>
          <span class="metric-pill info" th:text="${breweryUserCount} + ' accounts'">0 accounts</span>
        </header>
        <div class="metric-value" th:text="${breweryUserCount}">0</div>
        <footer class="muted">Users scoped to this brewery &amp; venues.</footer>
      <a class="card-link" th:href="@{/admin/brewery(tab='users')}">Manage team →</a>
      </article>
    </div>
  </section>

  <section class="page-section">
    <div class="section-heading">
      <div>
        <h2 th:text="${brewery != null ? brewery.name : 'Brewery'}">Brewery</h2>
        <p class="muted">Update your brewery details. Use the links on the left to dive deeper.</p>
      </div>
    </div>

    <form method="post" th:action="@{/admin/brewery/updateInfo}" class="form-inline">
      <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
      <div class="form-group">
        <label for="breweryName">Name</label>
        <input id="breweryName" type="text" name="name" required th:value="${brewery != null ? brewery.name : ''}" />
      </div>
      <div class="form-actions">
        <button class="btn primary" type="submit">Save changes</button>
      </div>
    </form>

    <div class="control-links">
      <a th:href="@{/admin/brewery(tab='taprooms')}" class="control-link" th:classappend="${tab == 'taprooms'} ? ' active' : ''">Taproom list</a>
      <a th:href="@{/admin/brewery(tab='kegs')}" class="control-link" th:classappend="${tab == 'kegs'} ? ' active' : ''">Brewery kegs</a>
      <a th:href="@{/admin/brewery(tab='assigned')}" class="control-link" th:classappend="${tab == 'assigned'} ? ' active' : ''">Assigned to venues</a>
      <a th:href="@{/admin/brewery(tab='returned')}" class="control-link" th:classappend="${tab == 'returned'} ? ' active' : ''">Returned inventory</a>
      <a th:href="@{/admin/brewery(tab='users')}" class="control-link" th:classappend="${tab == 'users'} ? ' active' : ''">Team members</a>
      <a th:href="@{/admin/brewery(tab='catalog')}" class="control-link" th:classappend="${tab == 'catalog'} ? ' active' : ''">Brewery catalog</a>
    </div>
  </section>

    <section class="page-section" th:if="${tab == null or tab == 'taprooms'}">
    <div class="section-heading">
      <div>
        <h3>Taproom coverage</h3>
        <p class="muted">Search, manage, and jump into individual taproom consoles.</p>
      </div>
    </div>

    <div class="stacked-forms">
      <form method="get" th:action="@{/admin/brewery}" class="form-inline">
        <input type="hidden" name="tab" value="taprooms" />
        <div class="form-group">
          <label for="taproomSearch">Search taprooms</label>
          <input id="taproomSearch" name="q" placeholder="Taproom name…" th:value="${q}" />
        </div>
        <div class="form-actions">
          <button class="btn secondary" type="submit">Search</button>
        </div>
      </form>

      <form method="post" th:action="@{/admin/brewery/taprooms/add}" class="form-inline">
        <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
        <div class="form-group">
          <label for="newTaproomName">Add taproom</label>
          <input id="newTaproomName" type="text" name="name" placeholder="Taproom name" required />
        </div>
        <div class="form-actions">
          <button class="btn primary" type="submit">Add taproom</button>
        </div>
      </form>
    </div>

    <div class="table-wrapper">
      <table class="table">
        <thead>
        <tr>
          <th>Name</th>
          <th>Taps</th>
          <th>Active kegs</th>
          <th aria-label="Actions"></th>
        </tr>
        </thead>
        <tbody>
        <tr th:each="t : ${taprooms}">
          <td th:text="${t.name}">Taproom</td>
          <td th:text="${tapsByTaproom[t.id] != null ? tapsByTaproom[t.id].size() : 0}">0</td>
          <td th:text="${activeKegsByTaproom[t.id] != null ? activeKegsByTaproom[t.id] : 0}">0</td>
          <td class="actions">
            <a class="btn ghost" th:href="@{/admin/taproom(taproomId=${t.id},from='brewery')}" th:text="${'Manage'}">Manage</a>
            <form method="post" th:action="@{'/admin/brewery/taprooms/' + ${t.id} + '/delete'}" class="form-inline form-inline--compact">
              <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
              <div class="form-actions">
                <button class="btn critical outline" type="submit">Remove</button>
              </div>
            </form>
          </td>
        </tr>
        <tr th:if="${#lists.isEmpty(taprooms)}">
          <td class="muted" colspan="4">No taprooms connected yet.</td>
        </tr>
        </tbody>
      </table>
    </div>
  </section>

  <section class="page-section" th:if="${tab == 'kegs'}">
    <div class="section-heading">
      <div>
        <h3>In-house kegs</h3>
        <p class="muted">Filter brewery-controlled inventory and distribute to venues.</p>
      </div>
    </div>

    <div class="filter-chip-row">
      <span class="muted">Status:</span>
      <a th:href="@{/admin/brewery(tab='kegs')}"
         th:classappend="${selectedStatus == null} ? ' filter-chip active' : ' filter-chip'">All</a>
      <a th:each="s : ${allStatuses}"
         th:href="@{/admin/brewery(tab='kegs', status=${s})}"
         th:text="${s}"
         th:classappend="${selectedStatus == s} ? ' filter-chip active' : ' filter-chip'">FILLED</a>
    </div>

    <div class="table-wrapper">
      <table class="table">
        <thead>
        <tr>
          <th>Serial</th>
          <th>Beer</th>
          <th>Size</th>
          <th>Status</th>
          <th>Assigned venue</th>
          <th aria-label="Actions"></th>
        </tr>
        </thead>
        <tbody>
        <tr th:each="k : ${kegs}">
          <td th:text="${k.serialNumber}">SER-001</td>
          <td th:text="${k.beer != null ? k.beer.name : '-'}">Beer</td>
          <td th:text="${k.size}">HALF_BARREL</td>
          <td>
            <span class="badge"
                  th:classappend="${k.status == T(com.mythictales.bms.taplist.domain.KegStatus).FILLED} ? ' green' :
                                  (k.status == T(com.mythictales.bms.taplist.domain.KegStatus).DISTRIBUTED ? ' blue' :
                                  (k.status == T(com.mythictales.bms.taplist.domain.KegStatus).RECEIVED ? ' purple' :
                                  (k.status == T(com.mythictales.bms.taplist.domain.KegStatus).TAPPED ? ' orange' :
                                  (k.status == T(com.mythictales.bms.taplist.domain.KegStatus).BLOWN ? ' red' : ' gray'))))"
                  th:text="${k.status}">FILLED</span>
          </td>
          <td th:text="${k.assignedVenue != null ? k.assignedVenue.name : '-'}">-</td>
          <td class="actions">
            <form method="post" th:action="@{'/admin/brewery/kegs/' + ${k.id} + '/distribute'}" class="form-inline form-inline--compact">
              <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
              <div class="form-group">
                <label class="sr-only" th:for="${'venue-' + k.id}">Select venue</label>
                <select th:id="${'venue-' + k.id}" name="venueId" required>
                  <option value="" disabled selected>Select venue…</option>
                  <option th:each="v : ${venues}" th:value="${v.id}" th:text="${v.name}">Venue</option>
                </select>
              </div>
              <div class="form-actions">
                <button class="btn secondary" type="submit">Distribute</button>
              </div>
            </form>
            <form method="post" th:action="@{'/admin/brewery/kegs/' + ${k.id} + '/clean'}" class="form-inline form-inline--compact">
              <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
              <div class="form-actions">
                <button class="btn ghost" type="submit">Mark clean</button>
              </div>
            </form>
          </td>
        </tr>
        <tr th:if="${#lists.isEmpty(kegs)}">
          <td class="muted" colspan="6">No kegs match the selected filter.</td>
        </tr>
        </tbody>
      </table>
    </div>
  </section>

  <section class="page-section" th:if="${tab == 'assigned'}">
    <div class="section-heading">
      <div>
        <h3>Assigned to venues</h3>
        <p class="muted">Track distributed kegs and recall when needed.</p>
      </div>
    </div>

    <div class="filter-chip-row">
      <span class="muted">Status:</span>
      <a th:href="@{/admin/brewery(tab='assigned', assignedVenueId=${assignedVenueId})}"
         th:classappend="${selectedStatus == null} ? ' filter-chip active' : ' filter-chip'">All</a>
      <a th:each="s : ${allStatuses}"
         th:href="@{/admin/brewery(tab='assigned', status=${s}, assignedVenueId=${assignedVenueId})}"
         th:text="${s}"
         th:classappend="${selectedStatus == s} ? ' filter-chip active' : ' filter-chip'">FILLED</a>
    </div>

    <form method="get" th:action="@{/admin/brewery}" class="form-inline">
      <input type="hidden" name="tab" value="assigned" />
      <input type="hidden" name="status" th:value="${selectedStatus}" />
      <div class="form-group">
        <label for="assignedVenue">Filter by venue</label>
        <select id="assignedVenue" name="assignedVenueId">
          <option value="">All venues</option>
          <option th:each="v : ${venues}" th:value="${v.id}" th:text="${v.name}"
                  th:selected="${assignedVenueId} == ${v.id}">Venue</option>
        </select>
      </div>
      <div class="form-actions">
        <button class="btn secondary" type="submit">Apply</button>
      </div>
    </form>

    <div class="table-wrapper">
      <table class="table">
        <thead>
        <tr>
          <th>Serial</th>
          <th>Beer</th>
          <th>Size</th>
          <th>Status</th>
          <th>Venue</th>
          <th aria-label="Actions"></th>
        </tr>
        </thead>
        <tbody>
        <tr th:each="k : ${assignedKegs}">
          <td th:text="${k.serialNumber}">SER-020</td>
          <td th:text="${k.beer != null ? k.beer.name : '-'}">Beer</td>
          <td th:text="${k.size}">SIXTEL</td>
          <td>
            <span class="badge"
                  th:classappend="${k.status == T(com.mythictales.bms.taplist.domain.KegStatus).FILLED} ? ' green' :
                                  (k.status == T(com.mythictales.bms.taplist.domain.KegStatus).DISTRIBUTED ? ' blue' :
                                  (k.status == T(com.mythictales.bms.taplist.domain.KegStatus).RECEIVED ? ' purple' :
                                  (k.status == T(com.mythictales.bms.taplist.domain.KegStatus).TAPPED ? ' orange' :
                                  (k.status == T(com.mythictales.bms.taplist.domain.KegStatus).BLOWN ? ' red' : ' gray'))))"
                  th:text="${k.status}">FILLED</span>
          </td>
          <td th:text="${k.assignedVenue != null ? k.assignedVenue.name : '-'}">Venue</td>
          <td class="actions">
            <form method="post" th:action="@{'/admin/brewery/kegs/' + ${k.id} + '/return'}" class="form-inline form-inline--compact">
              <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
              <div class="form-actions">
                <button class="btn ghost" type="submit">Mark returned</button>
              </div>
            </form>
          </td>
        </tr>
        <tr th:if="${#lists.isEmpty(assignedKegs)}">
          <td class="muted" colspan="6">No distributed kegs match the filters.</td>
        </tr>
        </tbody>
      </table>
    </div>
  </section>

  <section class="page-section" th:if="${tab == 'returned'}">
    <div class="section-heading">
      <div>
        <h3>Returned inventory</h3>
        <p class="muted">Kegs back from venues and ready for cleaning.</p>
      </div>
    </div>

    <div class="table-wrapper">
      <table class="table">
        <thead>
        <tr>
          <th>Serial</th>
          <th>Beer</th>
          <th>Size</th>
          <th>Status</th>
        </tr>
        </thead>
        <tbody>
        <tr th:each="k : ${returnedKegs}">
          <td th:text="${k.serialNumber}">SER-040</td>
          <td th:text="${k.beer != null ? k.beer.name : '-'}">Beer</td>
          <td th:text="${k.size}">HALF_BARREL</td>
          <td>
            <span class="badge gray" th:text="${k.status}">RETURNED</span>
          </td>
        </tr>
        <tr th:if="${#lists.isEmpty(returnedKegs)}">
          <td class="muted" colspan="4">No kegs have been returned yet.</td>
        </tr>
        </tbody>
      </table>
    </div>
  </section>

  <section class="page-section" th:if="${tab == 'users'}">
    <div class="section-heading">
      <div>
        <h3>Brewery users</h3>
        <p class="muted">Filter by venue to review scoped access.</p>
      </div>
    </div>

    <div class="alert" th:if="${errorMessage != null}" th:text="${errorMessage}"></div>
    <div class="alert success-alert" th:if="${successMessage != null}" th:text="${successMessage}"></div>

    <form class="form-grid" method="post" th:action="@{/admin/brewery/users}">
      <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
      <div class="form-group">
        <label for="brew-username">Username</label>
        <input id="brew-username" name="username" type="text" required />
      </div>
      <div class="form-group">
        <label for="brew-password">Password</label>
        <input id="brew-password" name="password" type="password" required />
      </div>
      <div class="form-group">
        <label for="brew-role">Role</label>
        <select id="brew-role" name="role">
          <option th:each="r : ${breweryUserRoles}" th:value="${r}" th:text="${#strings.replace(r.name(),'_',' ')}"></option>
        </select>
      </div>
      <div class="form-group">
        <label for="brew-taproom">Taproom</label>
        <select id="brew-taproom" name="taproomId">
          <option value="">-- None --</option>
          <option th:each="t : ${taprooms}" th:value="${t.id}" th:text="${t.name}"></option>
        </select>
      </div>
      <div class="form-group">
        <label for="brew-bar">Bar</label>
        <select id="brew-bar" name="barId">
          <option value="">-- None --</option>
          <option th:each="b : ${breweryBars}" th:value="${b.id}" th:text="${b.name}"></option>
        </select>
      </div>
      <div class="form-actions">
        <button class="btn primary" type="submit">Create user</button>
      </div>
    </form>

    <form method="get" action="/admin/brewery" class="form-inline">
      <input type="hidden" name="tab" value="users" />
      <div class="form-group">
        <label for="userVenue">Filter by venue</label>
        <select id="userVenue" name="userVenueId">
          <option value="">All venues</option>
          <option th:each="v : ${venues}" th:value="${v.id}" th:text="${v.name}"
                  th:selected="${userVenueId} == ${v.id}">Venue</option>
        </select>
      </div>
      <div class="form-actions">
        <button class="btn secondary" type="submit">Apply</button>
      </div>
    </form>

    <div class="table-wrapper">
      <table class="table">
        <thead>
        <tr>
          <th>Username</th>
          <th>Role</th>
          <th>Brewery</th>
          <th>Taproom</th>
          <th>Bar</th>
          <th>Actions</th>
        </tr>
        </thead>
        <tbody>
        <tr th:each="u : ${breweryUsers}">
          <td th:text="${u.username}">user</td>
          <td th:text="${#strings.replace(u.role,'ROLE_','')}">role</td>
          <td th:text="${u.brewery != null ? u.brewery.name : '-'}">-</td>
          <td th:text="${u.taproom != null ? u.taproom.name : '-'}">-</td>
          <td th:text="${u.bar != null ? u.bar.name : '-'}">-</td>
          <td class="actions">
            <form method="post" th:action="@{'/admin/brewery/users/' + ${u.id} + '/delete'}">
              <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
              <button class="btn ghost" type="submit">Remove</button>
            </form>
          </td>
        </tr>
        <tr th:if="${#lists.isEmpty(breweryUsers)}">
          <td class="muted" colspan="6">No users found for the selected filter.</td>
        </tr>
        </tbody>
      </table>
    </div>
  </section>

  <section class="page-section" th:if="${tab == 'catalog'}">
    <div class="section-heading">
      <div>
        <h3>Brewery catalog</h3>
        <p class="muted">Beers attached to active kegs or owned by this brewery.</p>
      </div>
    </div>

    <div class="card-grid">
      <article class="content-card" th:each="beer : ${catalogBeers}">
        <header>
          <div>
            <h3 th:text="${beer.name}">Beer Name</h3>
            <p class="muted" th:text="${beer.style}">Style</p>
          </div>
        </header>
        <footer class="muted">
          ABV <span th:text="${beer.abv}">0</span>%
        </footer>
      </article>
      <article class="content-card" th:if="${#lists.isEmpty(catalogBeers)}">
        <header>
          <div>
            <h3>Catalog empty</h3>
            <p class="muted">Link beers to kegs or assign BJCP styles to populate this view.</p>
          </div>
        </header>
      </article>
    </div>
  </section>
  </th:block>
</section>
</html>
